---
layout: edu
title:  "백준 1259 - 팰린드롬수 문제해설"
date:   2021-02-08 10:31:00 +9000
category: [ Education ]
tags: [ Python, Education ]
---

[문제 링크](https://www.acmicpc.net/problem/1259)

<br>

# **백준 온라인 저지 1259번 - 팰린드롬수 문제해설**
## **문제**
어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. 'radar', 'sees'는 팰린드롬이다.

수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다. 123, 1231은 뒤에서부터 읽으면 다르므로 팰린드롬수가 아니다. 또한 10도 팰린드롬수가 아닌데, 앞에 무의미한 0이 올 수 있다면 010이 되어 팰린드롬수로 취급할 수도 있지만, 특별히 이번 문제에서는 무의미한 0이 앞에 올 수 없다고 하자.

### **입력**
입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다. 입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다.

### **출력**
각 줄마다 주어진 수가 팰린드롬수면 'yes', 아니면 'no'를 출력한다.

<br>

### 예제 입력
    121
    1231
    12421
    0

### 예제 출력
    yes
    no
    yes

<br>

---

## **해설**
주어진 단어가 팰린드롬인지 아닌지 판단하는 문제이다.   
이 문제는 아직 문제를 많이 풀어보지 않은 입장에선 익숙지 않은 입출력 방식을 요구하기에 입력과 출력을 먼저 설명하려 한다.

> 입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다. 입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다.

테스트 케이스의 수를 따로 주지 않고 반복문을 통해 여러 테스트를 수행하다 특정한 입력이 들어왔을 때 프로그램을 종료하는 형태이다. 이는 아래의 두 가지 방법으로 코드를 작성할 수 있겠다.

```python
number = input()           # 반복문 시작 전 입력을 받음
while number[0] != '0':    # 특정한 입력이 아니라면 반복

    # 어떠한 코드...

    number = input()       # 반복문의 마지막에 다시 입력을 받는다.
```

```python
while True:                # 무한 반복문에 코드를 작성
    number = input()       # 반복문 처음 입력을 받는다.
    if number[0] == '0':   # 특정한 입력이라면
        break              # 반복문을 탈출한다.

    # 어떠한 코드...
```

두 방법 다 while문을 사용하며 첫 번째는 while문의 조건에 반복문이 유지돼야 하는 조건을 명시하였고 두 번째는 무한반복문 내에서 탈출해야 하는 조건을 명시하였다.   
혹시나 이해가 안 된다면 코드와 주석을 다시 찬찬히 읽고 본인의 환경에서 코드를 실행해보길 바란다. 답안 코드에서는 두 번째 방식을 사용하였다.

<br>

이렇게 입력의 틀을 잡았다면 이제 반복문 내부에 실제 문제를 해결하는 코드를 작성하면 된다. 팰린드롬은 가운데 문자를 중심으로 대칭이 되므로 서로 대칭되는 문자끼리 비교하며 전부 같다면 팰린드롬이며, 서로 다른 문자쌍이 있다면 팰린드롬이 아니다.

![비교예시1](/assets/solve_boj_1259(1).png)
![비교예시2](/assets/solve_boj_1259(2).png)

<br>

`i`번 색인의 문자와 대칭인 문자의 색인은 `(문자열의 길이) - 1 - i`와 같다. 이를 다음과 같이 for문을 사용하여 구현할 수 있겠다.

```python
bPalindrome = True     # 단어가 팰린드롬이라 가정
length = len(number)

for index in range(length):
    # 대칭인 문자와 동일한지확인
    if number[index] != numbe[length - index - 1]:
        bPalindrome = False
        break          # 다르다면 팰린드롬이 아니므로 반복문 탈출

# 이 시점에서 bPalindrome이 True라면 팰린드롬 False라면 팰린드롬이 아니다.
```

반복문을 통해 대칭되는 쌍의 문자들을 비교해간다. 만약 팰린드롬이라면 반복문이 끝까지 잘 실행될 것이고, 팰린드롬이 아니라 문자쌍이 다른 경우가 있다면 반복문이 중간에 끝날 것이다. 반복문이 끝까지 실행됐는지 여부는 여러 방법으로 확인해볼 수 있지만 본 코드에서는 불 자료형 `bPalindrome`을 추가하여 확인하였다. 결과적으로 문자열이 팰린드롬이라면 `bPalindrome`이 True 아니라면 False를 저장하고 있을 것이다. 팰린드롬 여부가 결정되었다면 이를 통해 결괏값을 출력해주면 된다.



<br>

---

## **답안 코드**
```python
while True:                # 무한 반복문에 코드를 작성
    number = input()       # 반복문 처음 입력을 받는다.
    if number[0] == '0':   # 특정한 입력이라면
        break              # 프로그램을 종료한다.
    
    bPalindrome = True
    length = len(number)   # 문자열의 길이를 여러번 사용할 것이므로 변수에 저장하여 사용
    
    for index in range(length):
        # 대칭인 문자와 동일한지확인
        if number[index] != number[length - index - 1]:
            bPalindrome = False
            break        # 다르다면 팰린드롬이 아니므로 반복문을 탈출한다.
    
    if bPalindrome:      # 반복문이 끝까지 실행되었다면 팰린드롬
        print('yes')
    else:                # 중간에 탈출했다면 팰린드롬이 아니다.
        print('no')
```

코딩을 하다 보면 리스트나 문자열을 사용하면서 양 끝에서 안쪽으로 탐색을 수행해가는 경우가 종종 있다. 이번 문제는 그런 탐색 방식의 기초적인 유형이라 할 수 있겠다.   
추가로 문자열 전체가 아닌 중간까지만 문자쌍을 확인하여도 팰린드롬임을 확인하는 데 지장이 없다. 직접 코딩해볼 때 답안에 이러한 부분을 적용하고 결과를 확인해보길 바란다. 탐색 범위가 절반으로 줄어듦으로 실행 시간 또한 절반이지만 최종 결과는 동일할 것이다.